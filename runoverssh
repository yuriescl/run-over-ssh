#!/usr/bin/env sh

# This program runs a shell command/script over SSH in a remote host or list of hosts
# Copyright (C) 2017  Yuri Escalianti   (https://github.com/yuriescl/runoverssh)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# Script name
script_name=`basename "$0"`
script_alias=`basename -s .sh "$0"`

# Print help
print_help() {
  echo "Usage: ${script_name} [OPTIONS] USERNAME COMMAND HOSTS..."
  echo "Runs a shell command/script over ssh in one or more hosts."
  echo "Options:"
  echo ""
  echo "   -g, --globalpw             ask one global password for all connections"
  echo "   -s, --script [file]        read commands from a script file instead"
  echo "   -r, --hostsfile [file]     use the list of hosts from a file (one host per line)"
  echo ""
  echo "   -n, --nopw                 no password (use ssh directly instead of sshpass)"
  echo "   -a, --args                 specify the arguments to be passed to the script file"
  echo "   -l, --log                  save ssh output (default: ${script_alias}.log) (append)"
  echo "   -q, --quiet                disable ssh screen output"
  echo ""
  echo "   --shellflags [flags]       set custom shell flags"
  echo "                              default (bash): '-l'"
  echo "   --sshflags [flags]         set custom ssh flags"
  echo "                              default: '-o ConnectTimeout=5 -o StrictHostKeyChecking=no'"
  echo "   --logfile [file]           save ssh output to a custom file (append)"
  echo ""
  echo "Examples:"
  echo ""
  echo "  runoverssh root 'systemctl restart apache2' server1 server2"
  echo ""
  echo "  runoverssh --log --quiet --globalpw root 'reboot' host1 host2 host3"
  echo ""
  echo "  runoverssh remoteuser 'cd git-project && git status' devmachine"
  echo ""
  echo "  runoverssh --script myscript.sh --hostsfile hostlist remoteuser"
  echo ""
  echo "  runoverssh --script myscript.sh --args '-q -s -t' --hostsfile hostlist remoteuser"
  echo ""
  echo "Bugs or Requests: https://github.com/yuriescl/runoverssh/issues"
}

# Standard parameters
username=""
remote_command=""

# Optional parameters
scriptfile=""  # -s , --script
args="" # -a , --args
hostsfile=""  # -r , --hostsfile
log=""  # -l , --log
logfile="${script_alias}.log"  # --logfile
globalpw=""  # -g, --globalpw
nopw=""  # -n, --nopw
sshflags="-o ConnectTimeout=5 -o StrictHostKeyChecking=no"   # --sshflags
shellflags="-l"  # --shellflags
quiet="" # -q , --quiet

if [ "$1" = "--help" ]; then
  print_help
  exit 0
else
  # Check parameter count
  if [ $# -lt 3 ]; then
    echo "Usage: ${script_name} [OPTIONS] USERNAME COMMAND HOSTS..."
    echo "Use '${script_name} --help' for command help and examples."
    exit 1
  fi
fi

# Read parameters

is_first=""
waiting_option=""
for parameter do
  if [ -n "${is_first}" ] && [ -n "${waiting_option}" ]; then

    # Assign the option
    case "${waiting_option}" in
      "-s" | "--script")
        scriptfile="${parameter}"
        ;;
      "-a" | "--args")
        args="${parameter}"
        ;;
      "-r" | "--hostsfile")
        hostsfile="${parameter}"
        ;;
      "--logfile")
        log="true"
        logfile="${parameter}"
        ;;
      "--sshflags")
        sshflags="${parameter}"
        ;;
      "--shellflags")
        shellflags="${parameter}"
        ;;
    esac
    waiting_option=""
  
  else  # first or not waiting option
    is_first="no"
    case "${parameter}" in
      "-s" | "--script" | "-a" | "--args" | "-r" | "--hostsfile" | "--logfile" | "--sshflags" | "--shellflags")
        waiting_option="${parameter}"
        ;;
      "-g" | "--globalpw")
        globalpw="true"
        ;;
      "-n" | "--nopw")
        nopw="true"
        ;;
      "-l" | "--log")
        log="true"
        ;;
      "-q" | "--quiet")
        quiet="true"
        ;;
      *)
        case "${$parameter}" in
          "--"*)
            echo "Error: invalid option '${parameter}'. Exiting."
            exit 1 ;;
          "-"*)
            echo "Error: invalid option '${parameter}'. Exiting."
            exit 1 ;;
          *) ;;
        esac

        # Read the end arguments
        
        if [ -z "${username}" ]; then
          username=${parameter}
        else
          if [ -z "${scriptfile}" ] && [ -z "${remote_command}" ]; then
            remote_command="${parameter}"
          else
            if [ -z "${hostsfile}" ]; then
                #TODO: stopped here. How to simulate an array in POSIX?
              hosts+=("${parameter}")
            fi # host
          fi #command
        fi #username
        waiting_option=""
    esac
  
  fi  # ! is_first and is waiting
done

# Check parameter and argument consistency

if [ -n "${waiting_option}" ]; then
  echo "Error: missing value for '${waiting_option}' parameter. Exiting."
  exit 1
fi

if [ -z "${username}" ]; then
  echo "Error: please specify the username to be used in SSH. Exiting."
  exit 1
fi

if [ -z "${scriptfile}" ] && [ -z "${remote_command}" ] ; then
  echo "Error: please specify the command or script file ('-s') to be executed over SSH. Exiting."
  exit 1
fi
if [ -n "${scriptfile}" ] && [ -n "${remote_command}" ] ; then
  echo "Error: parameter conflict: do not put a command as argument when also specifying a script as parameter. Exiting."
  exit 1
fi

if [ -n "${args}" ] && [ -z "${scriptfile}" ]; then
  echo "Error: arguments specified but no script file provided. Exiting."
  exit 1
fi

if [ -z "${hostsfile}" ] && [ ${#hosts[@]} -eq 0 ]; then
  echo "Error: please specify at least one target host or use the '--hostsfile' option. Exiting."
  exit 1
fi
if [ -n "${hostsfile}" ] && [ ${#hosts[@]} -gt 0 ]; then
  echo "Error: parameter conflict: do not list hosts as arguments when also specifying a hostsfile as parameter. Exiting."
  exit 1
fi

if [ -n "${globalpw}" ] && [ -n "${nopw}" ]; then
  echo "Error: parameter conflict: do not set the 'no password' option when also specifying a global password. Exiting.";
  exit 1
fi

# Check file readability (if specified to read from a file)

if [ -n "${hostsfile}" ] && [ ! -r "${hostsfile}" ]; then
	echo "Error: can't read the hosts file '${hostsfile}'. Exiting."
	exit 1
fi
if [ -n "${scriptfile}" ] && [ ! -r "${scriptfile}" ]; then
	echo "Error: can't read the script file '${scriptfile}'. Exiting."
  exit 1
fi

# Check log file
if [ -d "${logfile}" ]; then
  echo "Error: log file '${logfile}' is a directory. Exiting."
  exit 1
fi

# In case the hostsfile was used, fill the hosts array with them
if [ -n "${hostsfile}" ]; then
  hosts=()
  while read host; do
    if [ -n "${host}" ]; then
      hosts+=("${host}")
    fi
  done<"${hostsfile}"
fi

# Check dependencies
command -v "ssh" >/dev/null 2>&1 || { echo >&2 "Error: program 'ssh' not found. Exiting."; exit 1; }

# Check for sshpass if the option '-n' is not set
if [ -z "${nopw}" ]; then
  command -v "sshpass" >/dev/null 2>&1 || { echo >&2 "Error: program 'sshpass' not found (use the '-n' option to use 'ssh' instead). Exiting."; exit 1; }
fi


if [ -z "${nopw}" ]; then
  if [ -n "${globalpw}" ]; then
    printf "${username}\'s password (used for all connections): "
    read -s gpassword
    echo ""
  fi
fi

echo ""

if [ -z "${log}" ]; then
  logfile="/dev/null"
fi

# Connect to each host and execute the command/script
if [ -n "${nopw}" ]; then
  for host in "${hosts[@]}" 
  do
    echo "Connecting as ${username}@${host}..."
    if [ -n "${scriptfile}" ]; then
      if [ -n "${quiet}" ]; then
        ssh ${sshflags} ${username}@${host} "bash ${shellflags} -s" < "${scriptfile}" "${args}" >> "${logfile}"
      else
        ssh ${sshflags} ${username}@${host} "bash ${shellflags} -s" < "${scriptfile}" "${args}" | tee -a "${logfile}"
      fi
    else
      if [ -n "${quiet}" ]; then
        ssh ${sshflags} ${username}@${host} "bash ${shellflags} -c \"${remote_command}\"" >> "${logfile}"
      else
        ssh ${sshflags} ${username}@${host} "bash ${shellflags} -c \"${remote_command}\"" | tee -a "${logfile}"
      fi
    fi
  done
else
  i=0
  for host in "${hosts[@]}" 
  do
    echo "Connecting as ${username}@${host}..."
    if [ -n "${scriptfile}" ]; then
      if [ -n "${quiet}" ]; then
        sshpass -p "${passwords[$i]}" ssh ${sshflags} ${username}@${host} "bash ${shellflags} -s" < "${scriptfile}" "${args}" >> "${logfile}"
      else
        sshpass -p "${passwords[$i]}" ssh ${sshflags} ${username}@${host} "bash ${shellflags} -s" < "${scriptfile}" "${args}" | tee -a "${logfile}"
      fi
    else
      if [ -n "${quiet}" ]; then
        sshpass -p "${passwords[$i]}" ssh ${sshflags} ${username}@${host} "bash ${shellflags} -c \"${remote_command}\"" >> "${logfile}"
      else
        sshpass -p "${passwords[$i]}" ssh ${sshflags} ${username}@${host} "bash ${shellflags} -c \"${remote_command}\"" | tee -a "${logfile}"
      fi
    fi

    i=$((i + 1))
  done
fi

exit 0

# end.
